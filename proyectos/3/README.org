#+title: Asignaci√≥n de memoria en un sistema real
#+options: toc:nil num:nil

#+begin_src yaml
Planteamiento: 2022.04.26
Entrega: 2022.05.08
#+end_src

# Pueden [[./calificaciones.org][consultar los comentarios y calificaciones del proyecto aqu√≠]].

Todos los sistemas operativos de uso general al d√≠a de hoy utilizan un
modelo de memoria basado en la /paginaci√≥n/, y /casi/ siempre (si le
concedemos la excepci√≥n a uno que otro sistemas construidos para el
/tiempo real duro/) memoria virtual.

Vamos a ver qu√© tanto podemos aprender u obtener de esta
informaci√≥n. Este proyecto buscar√° llevarlos a demostrar sus
conocimientos al extraer informaci√≥n de la memoria de procesos
reales.

** Reimplementaci√≥n de =pmap=

En Linux, les he mostrado que hay varias maneras para obtener la
informaci√≥n de la asignaci√≥n de memoria a un proceso. En clase usamos
por conveniencia la salida de =pmap=.

Trabajemos tan cerca como se pueda de la informaci√≥n /cruda/, tal como
nos las da el sistema operativo: Quiero que me presenten con una
implementaci√≥n b√°sica y un poquito ampliada /hecha por ustedes/ de
=pmap=.

Sugiero que usen como fuente para implementarlo la informaci√≥n que nos
da Linux en =/proc/${PID}/maps= y =/proc/${PID}/smaps=. (donde con
=${PID}= indico el ID del proceso que estemos analizando). Su programa
debe recibir como entrada el mapa de memoria de /cualquier proceso/
(al que tenga permiso de lectura, naturalmente), y entregar:

- Identificaci√≥n de las secciones en memoria, indicando el tama√±o de
  cada una de ellas. Adem√°s de las regiones /cl√°sicas/ que estudiamos,
  les pido que indiquen claramente las regiones correspondientes a
  /bibliotecas de sistema/ y a otros /archivos mapeados a memoria/.

- Representaci√≥n visual de la memoria del proceso. Naturalmente, no
  espero que sea a escala (a fin de cuentas, ¬øc√≥mo se ver√≠a un proceso
  de apenas 4MB ante la inmensidad de un espacio de direccionamiento
  de 48 bits? üòâ

  La representaci√≥n visual puede ser a partir de algo [[./ejemplo/repr_visual_bash_rpi0][como mi ejemplo]]
  (ver un poquito m√°s adelante para mayores detalles. Pero... ¬°√âchenle
  creatividad! Pueden generar una imagen (dando mucha mayor
  resoluci√≥n), presentar cada secci√≥n con un color distinto, etc.

  Ojo, mi ejemplo est√° construido a partir de procesar los archivos
  [[./ejemplo/maps_bash_rpi0.txt][maps_bash_rpi0.txt]] y [[./ejemplo/smaps_bash_rpi0.txt][smaps_bash_rpi0.txt]], que fueron obtenidos en
  una Raspberry Pi 0. Menciono esto porque es una plataforma de /32
  bits/ ‚Äî Y se nota cuando ven las direcciones.

*** Puede serles de utilidad...

Para reimplementar =pmap=, puede resultarles conveniente leer el
[[https://gitlab.com/procps-ng/procps/-/blob/master/pmap.c][c√≥digo fuente en C de pmap]]. Su lectura, a pesar de ser c√≥digo fuente
productivo en C con cosa de 20 a√±os de antig√ºedad, no est√° demasiado
m√°s all√° de lo que espero de ustedes üòâ.

Pueden referirse a la [[https://github.com/mmalecki/procps/blob/86073c3b5145fd7596a74642a15b9ad38ea488c2/pmap.c][primera versi√≥n funcional de =pmap=]] (de octubre
de 2002), pero no garantizo que siga funcionando: es posible que el
formato de la informaci√≥n provista por Linux haya cambiado.

** ¬øQu√© entregar?

Les pido que entreguen quiero un /programa ejecutable/ en el lenguaje
que m√°s les acomode, al cual yo le indique un PID, y me genere un mapa
como [[./donde_en_la_memoria/repr_visual_bash_rpi0][el que les doy como ejemplo]].

Como siempre, les pido que acompa√±en al programa con documentaci√≥n,
presentando tanto los puntos que consideren relevantes para un
/usuario final/ como aquellos √∫tiles para que un /compa√±ero
desarrollador/ comprenda su c√≥digo y pueda contribuir al desarrollo
(s√≠, ese /compa√±ero desarrollador/ soy yo üòâ)

** ¬øC√≥mo se califica?

- Entrega de un programa que intente resolver el planteamiento ‚áí 50%
  - De entrada: Cuenten con el 30%
  - Incluye documentaci√≥n con autores, estrategia, requisitos, etc. ‚áí 20%
- Puedo ejecutarlo (de ser necesario, compilarlo) /sin modificaci√≥n
  alguna/ ‚áí 10%
- Calidad del reconocimiento de las regiones de memoria ‚áí 10%
  - Texto, datos, heap, stack, bibliotecas, espacios vac√≠os... ¬øAlguna
    hip√≥tesis para las regiones que yo marqu√© como ¬´?¬ª?
- Representaci√≥n visual ‚áí Hasta 15%
  - Similar a mi ejemplo, 10%
  - Salida a color, gr√°fica, interactiva con alg√∫n detalle
    /interesante/, 5%
- Universalidad ‚áí 15%
  - Funciona con mis archivos de ejemplo, 5%
  - Funciona con procesos cualquiera de mi sistema, sean sencillos o
    complejos, 5% (les adelanto: voy a probarlo con =bash=, alg√∫n
    programa escrito en =Python=, Chromium, Firefox y alguno m√°s)
  - Funciona en equipos de 32 o 64 (ok, 48) bits sin problemas, 5%
